#!/usr/bin/env node

/**
 * Rule Generator - Auto-generate Cursor rules from template metadata
 *
 * Reads template .md files with metadata frontmatter and generates
 * corresponding .cursor/rules/*.mdc files automatically.
 *
 * Usage:
 *   sc rules regenerate --all
 *   sc rules regenerate architecture-pattern
 *   sc rules regenerate --dry-run
 */

const fs = require('fs-extra');
const path = require('node:path');
const chalk = require('chalk');
const matter = require('gray-matter');
const glob = require('glob');
const TemplateResolver = require('../utils/template-resolver');

class RuleGenerator {
  constructor(options = {}) {
    this.projectRoot = options.projectRoot || process.cwd();
    this.templateResolver = new TemplateResolver(this.projectRoot);
    this.rulesDir = path.join(this.projectRoot, '.cursor', 'rules');
    this.dryRun = options.dryRun || false;
    this.verbose = options.verbose || false;
  }

  /**
   * Find all templates with metadata
   */
  async findTemplates() {
    const templateFiles = glob.sync('**/*.template.md', {
      cwd: this.templatesDir,
      absolute: true
    });

    const templates = [];

    for (const templatePath of templateFiles) {
      const content = await fs.readFile(templatePath, 'utf8');
      const parsed = matter(content);

      // Check if template has metadata (starts with _)
      const hasMetadata = Object.keys(parsed.data).some((key) =>
        key.startsWith('_')
      );

      if (hasMetadata) {
        templates.push({
          path: templatePath,
          relativePath: path.relative(this.templatesDir, templatePath),
          metadata: this.extractMetadata(parsed.data),
          content: parsed.content
        });
      }
    }

    return templates;
  }

  /**
   * Extract template metadata (fields starting with _)
   */
  extractMetadata(frontmatter) {
    const metadata = {};
    const documentFields = {};

    for (const [key, value] of Object.entries(frontmatter)) {
      if (key.startsWith('_')) {
        metadata[key] = value;
      } else {
        documentFields[key] = value;
      }
    }

    return { ...metadata, _document_fields: documentFields };
  }

  /**
   * Generate a Cursor rule from template metadata
   */
  generateRule(template) {
    const { metadata, path: templatePath, relativePath } = template;

    if (!metadata._template_id) {
      throw new Error(
        `Template ${relativePath} missing _template_id in frontmatter`
      );
    }

    const ruleFilename = `auto-${metadata._template_id}.mdc`;
    const rulePath = path.join(this.rulesDir, ruleFilename);

    const content = this.buildRuleContent(metadata, templatePath);

    return {
      filename: ruleFilename,
      path: rulePath,
      content,
      metadata
    };
  }

  /**
   * Build the complete rule content
   */
  buildRuleContent(metadata, templatePath) {
    const timestamp = new Date().toISOString();
    const relativeTemplatePath = path.relative(this.projectRoot, templatePath);

    // Build globs pattern
    let globs = '';
    if (metadata._path_pattern) {
      const pattern = metadata._path_pattern.replace(/{[^}]+}/g, '*');
      globs = pattern;
    } else if (metadata._directory_base) {
      globs = `${metadata._directory_base}/**/*.md`;
    }

    // Frontmatter
    const frontmatter = {
      description: `${metadata._template_description || metadata._template_id} rules (auto-generated)`,
      globs: globs || '**/*',
      alwaysApply: false,
      _auto_generated: true,
      _source_template: relativeTemplatePath,
      _generated_at: timestamp,
      _template_version: metadata._template_version || '1.0'
    };

    let content = '---\n';
    for (const [key, value] of Object.entries(frontmatter)) {
      if (typeof value === 'string') {
        content += `${key}: ${value}\n`;
      } else {
        content += `${key}: ${JSON.stringify(value)}\n`;
      }
    }
    content += '---\n\n';

    // Header
    content += `# ${this.capitalize(metadata._template_id)} Documentation Rules\n\n`;
    content += `> **ðŸ¤– Auto-Generated Rule**\n`;
    content += `> \n`;
    content += `> This rule was automatically generated from the template metadata.\n`;
    content += `> \n`;
    content += `> **DO NOT EDIT THIS FILE DIRECTLY**\n`;
    content += `> \n`;
    content += `> To update this rule:\n`;
    content += `> 1. Edit the source template: \`${relativeTemplatePath}\`\n`;
    content += `> 2. Run: \`sc rules regenerate ${metadata._template_id}\`\n`;
    content += `> \n`;
    content += `> **Last Generated**: ${new Date().toLocaleString()}\n`;
    content += `> **Template Version**: ${metadata._template_version || '1.0'}\n\n`;
    content += `---\n\n`;

    // Quick Reference
    if (metadata._sc_commands) {
      content += `## Quick Reference\n\n`;
      if (metadata._sc_commands.create) {
        content += `**Create**: \`${metadata._sc_commands.create.trim()}\`\n`;
      }
      if (metadata._sc_commands.validate) {
        content += `**Validate**: \`${metadata._sc_commands.validate}\`\n`;
      }
      if (metadata._sc_commands.info) {
        content += `**Info**: \`${metadata._sc_commands.info}\`\n`;
      }
      content += `\n---\n\n`;
    }

    // File Naming
    if (metadata._naming_pattern || metadata._naming_examples) {
      content += this.buildNamingSection(metadata);
    }

    // Creating Documents
    if (metadata._sc_commands?.create) {
      content += this.buildCreationSection(metadata);
    }

    // Required Frontmatter
    if (metadata._required_fields) {
      content += this.buildFrontmatterSection(metadata);
    }

    // Required Sections
    if (metadata._required_sections) {
      content += this.buildSectionsSection(metadata);
    }

    // Code Conventions
    if (metadata._code_conventions) {
      content += this.buildCodeConventionsSection(metadata);
    }

    // Validation
    if (metadata._sc_commands?.validate) {
      content += this.buildValidationSection(metadata);
    }

    // Related Commands
    if (metadata._sc_commands) {
      content += this.buildRelatedCommandsSection(metadata);
    }

    // Related Templates
    if (metadata._related_templates) {
      content += this.buildRelatedTemplatesSection(metadata);
    }

    // Footer
    content += `---\n\n`;
    content += `## Template Details\n\n`;
    content += `**Template ID**: ${metadata._template_id}\n`;
    content += `**Template Location**: \`${relativeTemplatePath}\`\n`;
    content += `**Template Version**: ${metadata._template_version || '1.0'}\n\n`;
    content += `For more information:\n`;
    content += `\`\`\`bash\n`;
    content += `sc docs template-info ${metadata._template_id}\n`;
    content += `\`\`\`\n`;

    return content;
  }

  buildNamingSection(metadata) {
    let content = `## File Naming\n\n`;

    if (metadata._naming_examples?.length > 0) {
      content += `### âœ… Correct Pattern\n\n`;
      content += `\`\`\`\n`;
      if (metadata._directory_base) {
        content += `${metadata._directory_base}/\n`;
        metadata._naming_examples.forEach((ex) => {
          content += `â”œâ”€â”€ ${ex}\n`;
        });
      } else {
        metadata._naming_examples.forEach((ex) => {
          content += `${ex}\n`;
        });
      }
      content += `\`\`\`\n\n`;
    }

    if (metadata._naming_pattern) {
      content += `**Pattern**: \`${metadata._naming_pattern}\`\n`;
    }
    if (metadata._naming_style) {
      content += `**Style**: ${metadata._naming_style}\n`;
    }
    if (metadata._directory_base) {
      content += `**Location**: \`${metadata._directory_base}/\`\n`;
    }
    content += `\n`;

    content += `### âœ… DO\n\n`;
    if (metadata._naming_style) {
      content += `- Use ${metadata._naming_style} naming\n`;
    }
    if (metadata._sc_commands?.create) {
      content += `- Use the \`sc\` command: \`${metadata._sc_commands.create.split('\n')[0].trim()}\`\n`;
    }
    content += `\n`;

    if (metadata._naming_examples?.length > 0) {
      content += `**Examples**:\n`;
      metadata._naming_examples.forEach((ex) => {
        content += `- \`${ex}\` âœ“\n`;
      });
      content += `\n`;
    }

    if (metadata._naming_anti_examples?.length > 0) {
      content += `### âŒ DON'T\n\n`;
      metadata._naming_anti_examples.forEach((ex) => {
        const parts = ex.split('#');
        const filename = parts[0].trim();
        const reason = parts[1]?.trim() || '';
        content += `- \`${filename}\` âœ—`;
        if (reason) {
          content += ` - ${reason}`;
        }
        content += `\n`;
      });
      content += `\n`;
    }

    content += `---\n\n`;
    return content;
  }

  buildCreationSection(metadata) {
    let content = `## Creating New Documents\n\n`;
    content += `### Use SC Command (Recommended)\n\n`;
    content += `\`\`\`bash\n`;
    content += `${metadata._sc_commands.create.trim()}\n`;
    content += `\n`;
    content += `# This automatically:\n`;
    if (metadata._naming_pattern) {
      content += `# âœ“ Generates correct filename pattern\n`;
    }
    if (metadata._directory_base) {
      content += `# âœ“ Creates in correct directory: ${metadata._directory_base}/\n`;
    }
    content += `# âœ“ Fills required frontmatter\n`;
    content += `# âœ“ Creates required sections\n`;
    content += `# âœ“ Validates naming pattern\n`;
    content += `\`\`\`\n\n`;

    if (metadata._sc_command_examples?.create) {
      content += `### Creation Examples\n\n`;
      metadata._sc_command_examples.create.forEach((example) => {
        content += `\`\`\`bash\n`;
        content += `# ${example.description}\n`;
        content += `${example.command.trim()}\n`;
        content += `\`\`\`\n\n`;
      });
    }

    content += `---\n\n`;
    return content;
  }

  buildFrontmatterSection(metadata) {
    let content = `## Required Frontmatter\n\n`;
    content += `Every document MUST include these fields:\n\n`;
    content += `\`\`\`yaml\n---\n`;

    if (Array.isArray(metadata._required_fields)) {
      // Simple array
      metadata._required_fields.forEach((field) => {
        if (typeof field === 'string') {
          content += `${field}:\n`;
        }
      });
    } else if (typeof metadata._required_fields === 'object') {
      // Object with descriptions
      Object.entries(metadata._required_fields).forEach(([field, desc]) => {
        content += `${field}:              # ${desc}\n`;
      });
    }

    content += `---\n\`\`\`\n\n`;

    if (metadata._optional_fields?.length > 0) {
      content += `### Optional Fields\n\n`;
      content += `\`\`\`yaml\n`;
      metadata._optional_fields.forEach((field) => {
        content += `${field}:\n`;
      });
      content += `\`\`\`\n\n`;
    }

    content += `---\n\n`;
    return content;
  }

  buildSectionsSection(metadata) {
    let content = `## Required Document Sections\n\n`;
    content += `Every document must include these sections in order:\n\n`;

    metadata._required_sections.forEach((section, index) => {
      if (typeof section === 'string') {
        content += `${index + 1}. **${section}**\n`;
      } else if (section.heading) {
        content += `${index + 1}. **${section.heading}**\n`;
        if (section.description) {
          content += `   - ${section.description}\n`;
        }
      }
      content += `\n`;
    });

    content += `---\n\n`;
    return content;
  }

  buildCodeConventionsSection(metadata) {
    let content = `## Code Naming Conventions\n\n`;
    content += `When implementing code described in these documents, follow these naming conventions:\n\n`;

    const conventions = metadata._code_conventions;

    // Group by language if present
    content += `### TypeScript/JavaScript\n\n`;

    if (conventions.interface_naming) {
      content += `**Interfaces**:\n\`\`\`typescript\n`;
      content += `// âœ… DO: ${conventions.interface_naming.style}`;
      if (conventions.interface_naming.prefix) {
        content += ` with "${conventions.interface_naming.prefix}" prefix`;
      }
      content += `\n`;
      conventions.interface_naming.examples?.forEach((ex) => {
        content += `interface ${ex} { ... }\n`;
      });
      content += `\`\`\`\n\n`;
    }

    if (conventions.class_naming) {
      content += `**Classes**:\n\`\`\`typescript\n`;
      content += `// âœ… DO: ${conventions.class_naming.style}`;
      if (conventions.class_naming.suffix) {
        content += `, suffix: "${conventions.class_naming.suffix}"`;
      }
      content += `\n`;
      conventions.class_naming.examples?.forEach((ex) => {
        content += `class ${ex} { ... }\n`;
      });
      content += `\`\`\`\n\n`;
    }

    if (conventions.function_naming) {
      content += `**Functions**:\n\`\`\`typescript\n`;
      content += `// âœ… DO: ${conventions.function_naming.style}\n`;
      conventions.function_naming.examples?.forEach((ex) => {
        content += `function ${ex}() { ... }\n`;
      });
      content += `\`\`\`\n\n`;
    }

    if (conventions.constant_naming) {
      content += `**Constants**:\n\`\`\`typescript\n`;
      content += `// âœ… DO: ${conventions.constant_naming.style}\n`;
      conventions.constant_naming.examples?.forEach((ex) => {
        content += `const ${ex} = ...;\n`;
      });
      content += `\`\`\`\n\n`;
    }

    if (conventions.file_naming) {
      content += `### File Naming\n\n`;
      content += `**Implementation Files**:\n\`\`\`\n`;
      content += `src/\n`;
      conventions.file_naming.examples?.forEach((ex) => {
        content += `â”œâ”€â”€ ${ex}\n`;
      });
      content += `\`\`\`\n\n`;
    }

    if (conventions.test_file_naming) {
      content += `**Test Files**:\n`;
      content += `Pattern: \`${conventions.test_file_naming.pattern}\`\n\n`;
      content += `\`\`\`\n`;
      content += `tests/\n`;
      conventions.test_file_naming.examples?.forEach((ex) => {
        content += `â”œâ”€â”€ ${ex}\n`;
      });
      content += `\`\`\`\n\n`;
    }

    content += `---\n\n`;
    return content;
  }

  buildValidationSection(metadata) {
    let content = `## Validation\n\n`;
    content += `### Validate Your Document\n\n`;
    content += `\`\`\`bash\n`;
    content += `${metadata._sc_commands.validate}\n`;
    content += `\`\`\`\n\n`;
    content += `---\n\n`;
    return content;
  }

  buildRelatedCommandsSection(metadata) {
    let content = `## Related Commands\n\n`;

    Object.entries(metadata._sc_commands).forEach(([name, cmd]) => {
      if (name === 'create' || name === 'validate' || name === 'info') {
        return; // Already shown above
      }
      content += `**${this.capitalize(name)}**:\n`;
      content += `\`\`\`bash\n${cmd}\n\`\`\`\n\n`;
    });

    content += `---\n\n`;
    return content;
  }

  buildRelatedTemplatesSection(metadata) {
    let content = `## Related Templates\n\n`;

    metadata._related_templates.forEach((related) => {
      if (typeof related === 'string') {
        content += `- **${related}**\n`;
      } else {
        content += `- **${related.id}**`;
        if (related.relationship) {
          content += `: ${related.relationship}`;
        }
        content += `\n`;
      }
    });

    content += `\n---\n\n`;
    return content;
  }

  /**
   * Capitalize first letter
   */
  capitalize(str) {
    return str
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Generate all rules
   */
  async generateAll() {
    console.log(chalk.blue('ðŸ” Finding templates with metadata...\n'));

    const templates = await this.findTemplates();

    if (templates.length === 0) {
      console.log(chalk.yellow('No templates with metadata found'));
      return [];
    }

    console.log(
      chalk.green(`Found ${templates.length} template(s) with metadata:\n`)
    );

    const results = [];

    for (const template of templates) {
      try {
        const rule = this.generateRule(template);

        console.log(chalk.cyan(`  ${template.metadata._template_id}`));
        console.log(chalk.gray(`    Template: ${template.relativePath}`));
        console.log(chalk.gray(`    Rule: ${rule.filename}`));

        if (this.dryRun) {
          console.log(chalk.yellow('    [DRY RUN - not writing]'));
        } else {
          await fs.ensureDir(this.rulesDir);
          await fs.writeFile(rule.path, rule.content, 'utf8');
          console.log(chalk.green('    âœ“ Generated'));
        }

        console.log();

        results.push({
          success: true,
          template: template.relativePath,
          rule: rule.filename
        });
      } catch (error) {
        console.log(chalk.red(`  âœ— Error: ${error.message}`));
        console.log();

        results.push({
          success: false,
          template: template.relativePath,
          error: error.message
        });
      }
    }

    return results;
  }

  /**
   * Generate single rule
   */
  async generateOne(templateId) {
    const templates = await this.findTemplates();
    const template = templates.find(
      (t) => t.metadata._template_id === templateId
    );

    if (!template) {
      throw new Error(`Template with ID "${templateId}" not found`);
    }

    const rule = this.generateRule(template);

    if (!this.dryRun) {
      await fs.ensureDir(this.rulesDir);
      await fs.writeFile(rule.path, rule.content, 'utf8');
    }

    return rule;
  }
}

module.exports = RuleGenerator;

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);
  const dryRun = args.includes('--dry-run');
  const verbose = args.includes('--verbose') || args.includes('-v');
  const all = args.includes('--all');

  const generator = new RuleGenerator({ dryRun, verbose });

  if (all || args.length === 0) {
    generator
      .generateAll()
      .then((results) => {
        const succeeded = results.filter((r) => r.success).length;
        const failed = results.filter((r) => !r.success).length;

        console.log(chalk.bold('\nðŸ“Š Summary:'));
        console.log(chalk.green(`  âœ“ ${succeeded} rule(s) generated`));
        if (failed > 0) {
          console.log(chalk.red(`  âœ— ${failed} failed`));
        }

        if (dryRun) {
          console.log(
            chalk.yellow('\n[DRY RUN] No files were actually written')
          );
        }
      })
      .catch((err) => {
        console.error(chalk.red(`Error: ${err.message}`));
        process.exit(1);
      });
  } else {
    const templateId = args[0];
    generator
      .generateOne(templateId)
      .then((rule) => {
        console.log(chalk.green(`âœ“ Generated rule: ${rule.filename}`));
        if (dryRun) {
          console.log(chalk.yellow('[DRY RUN] File not written'));
        }
      })
      .catch((err) => {
        console.error(chalk.red(`Error: ${err.message}`));
        process.exit(1);
      });
  }
}
